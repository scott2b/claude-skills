#!/usr/bin/env python3
"""
Manage .app-runner.yml configuration files.

Usage:
    python manage_config.py check                    # Check if config exists
    python manage_config.py read                     # Read and output config
    python manage_config.py create --interactive     # Interactive config creation
"""

import sys
import json
import argparse
from pathlib import Path
from typing import Optional


def find_config_file(start_dir: Path = None) -> Optional[Path]:
    """
    Find .app-runner.yml in current directory or parent directories.

    Returns path to config file or None if not found.
    """
    if start_dir is None:
        start_dir = Path.cwd()

    current = start_dir
    searched = set()

    while current != current.parent and current not in searched:
        searched.add(current)

        config_file = current / '.app-runner.yml'
        if config_file.exists():
            return config_file

        # Stop at git root
        if (current / '.git').exists():
            break

        current = current.parent

    return None


def read_config(config_path: Path) -> dict:
    """Read and parse YAML config file."""
    try:
        import yaml
    except ImportError:
        # Fallback: simple YAML parser for basic configs
        return read_config_simple(config_path)

    with open(config_path) as f:
        return yaml.safe_load(f)


def read_config_simple(config_path: Path) -> dict:
    """
    Simple YAML parser for basic .app-runner.yml files.

    This is a fallback when PyYAML is not installed.
    Only handles simple key-value pairs and basic lists.
    """
    config = {}
    current_list = None
    current_dict = None

    with open(config_path) as f:
        for line in f:
            line = line.rstrip()

            # Skip empty lines and comments
            if not line or line.strip().startswith('#'):
                continue

            # Count indentation
            indent = len(line) - len(line.lstrip())

            # Top-level key
            if indent == 0 and ':' in line:
                key, _, value = line.partition(':')
                key = key.strip()
                value = value.strip()

                if value:
                    config[key] = value
                else:
                    config[key] = {}
                    current_dict = config[key]

    return config


def write_config(config_path: Path, config: dict):
    """Write configuration to YAML file."""
    try:
        import yaml
        with open(config_path, 'w') as f:
            yaml.dump(config, f, default_flow_style=False, sort_keys=False)
    except ImportError:
        # Fallback: write basic YAML manually
        write_config_simple(config_path, config)


def write_config_simple(config_path: Path, config: dict):
    """Simple YAML writer for basic configs."""
    with open(config_path, 'w') as f:
        f.write("# Application runner configuration\n")
        f.write("# Generated by app-runner skill\n\n")

        if 'service' in config:
            f.write("service:\n")
            service = config['service']
            if 'command' in service:
                f.write(f"  command: {service['command']}\n")
            if 'health_check' in service:
                hc = service['health_check']
                f.write("  health_check:\n")
                f.write(f"    url: {hc.get('url', '')}\n")
                f.write(f"    timeout: {hc.get('timeout', 30)}\n")

        if 'entry_point' in config:
            f.write(f"\nentry_point: {config['entry_point']}\n")


def interactive_create() -> dict:
    """
    Interactive configuration creation.

    Asks user questions and builds config.
    """
    print("\nüîß Let's configure how to run your application\n")

    # Ask about single or multiple services
    print("Does your application have:")
    print("  1. Single service (e.g., just npm run dev)")
    print("  2. Multiple services (e.g., frontend + backend + database)")

    choice = input("\nChoice (1 or 2): ").strip()

    if choice == '1':
        return create_single_service_config()
    else:
        return create_multi_service_config()


def create_single_service_config() -> dict:
    """Create configuration for single service."""
    print("\nüìù Single Service Configuration\n")

    command = input("Command to start your application: ").strip()
    url = input("URL to check when app is ready (e.g., http://localhost:3000): ").strip()
    timeout = input("Timeout in seconds to wait for startup (default: 30): ").strip()

    config = {
        'service': {
            'command': command,
            'health_check': {
                'url': url,
                'timeout': int(timeout) if timeout else 30
            }
        },
        'entry_point': url
    }

    return config


def create_multi_service_config() -> dict:
    """Create configuration for multiple services."""
    print("\nüìù Multiple Services Configuration\n")
    print("Enter details for each service. Press Enter with empty name to finish.\n")

    services = []

    while True:
        name = input("Service name (or Enter to finish): ").strip()
        if not name:
            break

        command = input(f"  Command to start {name}: ").strip()
        url = input(f"  Health check URL for {name}: ").strip()
        timeout = input(f"  Timeout in seconds (default: 30): ").strip()

        services.append({
            'name': name,
            'command': command,
            'health_check': {
                'url': url,
                'timeout': int(timeout) if timeout else 30
            }
        })

    entry_point = input("\nMain entry point URL for testing: ").strip()

    config = {
        'services': services,
        'entry_point': entry_point
    }

    return config


def main():
    parser = argparse.ArgumentParser(description='Manage app-runner configuration')
    parser.add_argument('action', choices=['check', 'read', 'create'],
                        help='Action to perform')
    parser.add_argument('--interactive', action='store_true',
                        help='Interactive mode for create action')
    parser.add_argument('--dir', type=Path, help='Directory to search for config')

    args = parser.parse_args()

    if args.action == 'check':
        config_path = find_config_file(args.dir)
        result = {
            'exists': config_path is not None,
            'path': str(config_path) if config_path else None
        }
        print(json.dumps(result))
        return 0 if config_path else 1

    elif args.action == 'read':
        config_path = find_config_file(args.dir)
        if not config_path:
            print(json.dumps({'error': 'Config file not found'}))
            return 1

        config = read_config(config_path)
        print(json.dumps(config, indent=2))
        return 0

    elif args.action == 'create':
        if args.interactive:
            config = interactive_create()

            # Save to current directory
            config_path = Path.cwd() / '.app-runner.yml'
            write_config(config_path, config)

            print(f"\n‚úÖ Configuration saved to: {config_path}")
            print("\nYou can edit this file manually if needed.")
            return 0
        else:
            print("Use --interactive flag for interactive config creation")
            return 1


if __name__ == '__main__':
    sys.exit(main())
